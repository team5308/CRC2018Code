                            // RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "AutonomousCommand.h"
#include <iostream>

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

AutonomousCommand::AutonomousCommand(): frc::Command() {
        // Use requires() here to declare subsystem dependencies
    // eg. requires(Robot::chassis.get());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time

//���Զ������аѻ������������Ž��е������ǲ���1 2�������������
void AutonomousCommand::Initialize() {
}

// Called repeatedly when this Command is scheduled to run
void AutonomusCommand::Excute()
{
    /*
        @targetMode 
        3 mode : switch, scale, crossline
        modify this varible to change auto mode
    */
    std::String targetmode = "scale";

    /*
       @GameDate Init
        function: store specific Game Data of direction of switch/scale
    */
    std::String GameData = "LLL";

    // get specific data from driverstation
     GameData = frc::DriverStation::GetInstance().GetGameSpecificMessage();

    if(targetMode == "switch") //do switch 
    {
        if(GameData[0] == 'L')  // if our switch is on left 
        {
            /*
                call corresponding auto function 
                all avaiable functions on AutonomousSystem Doc
            */
            printf("left switch 2 case\n");
            Robot::autonomusSystem->leftSwitch2Case(); 
        }
        else // if our switch is on right
        {
            /*
                call corresponding auto function 
                all avaiable functions on AutonomousSystem Doc
            */
            printf("right switch 2 case\n");
            Robot::autonomusSystem->rightSwitch2Case(); 
        }
    }
    else if(targetmode == "scale") //do scale thing
    {
        if(GameData[1] == 'L')  // if our scale is on left 
        {
            /*
                call corresponding auto function 
                all avaiable functions on AutonomousSystem Doc
            */
            printf("left scale\n");
            Robot::autonomusSystem->leftScale(); 
        }
        else // if our scale is on right
        {
            /*
               call corresponding auto function 
                all avaiable functions on AutonomousSystem Doc
            */
            printf("right scale\n");
            Robot::autonomusSystem->rightScale(); 
        } 
    }
    else //default mode (current cross line)
    {
        printf("cross line\n");
        Robot::autonomusSystem->setRunDfsMode(750, true);
    }
}

// Make this return true when this Command no longer needs to run execute()
bool AutonomousCommand::IsFinished() {
    return true;
}

// Called once after isFinished returns true
void AutonomousCommand::End() {
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void AutonomousCommand::Interrupted() {

}


